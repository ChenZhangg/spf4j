<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TSDBReader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-jacoco-aggregate</a> &gt; <a href="../index.html" class="el_bundle">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.tsdb2</a> &gt; <span class="el_source">TSDBReader.java</span></div><h1>TSDBReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.tsdb2;

import org.spf4j.io.CountingInputStream;
import com.google.common.io.ByteStreams;
import com.google.common.primitives.Longs;
import com.sun.nio.file.SensitivityWatchEventModifier;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.channels.Channels;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import org.apache.avro.Schema;
import org.apache.avro.io.BinaryDecoder;
import org.apache.avro.io.DecoderFactory;
import org.apache.avro.specific.SpecificDatumReader;
import org.spf4j.base.Either;
import org.spf4j.base.ExecutionContexts;
import org.spf4j.base.Handler;
import org.spf4j.base.TimeSource;
import org.spf4j.concurrent.DefaultExecutor;
import org.spf4j.io.MemorizingBufferedInputStream;
import org.spf4j.tsdb2.avro.DataBlock;
import org.spf4j.tsdb2.avro.Header;
import org.spf4j.tsdb2.avro.TableDef;

/**
 *
 * @author zoly
 */
@SuppressFBWarnings(&quot;IICU_INCORRECT_INTERNAL_CLASS_USE&quot;)
public final class TSDBReader implements Closeable {

<span class="fc" id="L79">  private static final boolean CORUPTION_LENIENT = Boolean.getBoolean(&quot;spf4j.tsdb2.lenientRead&quot;);</span>

  private CountingInputStream bis;
  private final Header header;
  private long size;
  private BinaryDecoder decoder;
  private final SpecificDatumReader&lt;Object&gt; recordReader;
  private RandomAccessFile raf;
  private final File file;
  private final Path filePath;
  private volatile boolean watch;
  private final int bufferSize;
  private final SeekableByteChannel byteChannel;

<span class="fc" id="L93">  public TSDBReader(final File file, final int bufferSize) throws IOException {</span>
<span class="fc" id="L94">    this.file = file;</span>
<span class="fc" id="L95">    this.filePath = file.toPath();</span>
<span class="fc" id="L96">    this.bufferSize = bufferSize;</span>
<span class="fc" id="L97">    this.byteChannel = Files.newByteChannel(filePath);</span>
<span class="fc" id="L98">    resetStream(0);</span>
<span class="fc" id="L99">    SpecificDatumReader&lt;Header&gt; reader = new SpecificDatumReader&lt;&gt;(Header.getClassSchema());</span>
<span class="fc" id="L100">    TSDBWriter.validateType(bis);</span>
<span class="fc" id="L101">    byte[] buff = new byte[8];</span>
<span class="fc" id="L102">    ByteStreams.readFully(bis, buff);</span>
<span class="fc" id="L103">    size = Longs.fromByteArray(buff);</span>
<span class="fc" id="L104">    header = reader.read(null, decoder);</span>
<span class="fc" id="L105">    recordReader = new SpecificDatumReader&lt;&gt;(</span>
<span class="fc" id="L106">            new Schema.Parser().parse(header.getContentSchema()),</span>
<span class="fc" id="L107">            Schema.createUnion(Arrays.asList(TableDef.SCHEMA$, DataBlock.SCHEMA$)));</span>
<span class="fc" id="L108">  }</span>

  private void resetStream(final long position) throws IOException {
<span class="fc" id="L111">    byteChannel.position(position);</span>
<span class="fc" id="L112">    bis = new CountingInputStream(new MemorizingBufferedInputStream(Channels.newInputStream(byteChannel),</span>
            bufferSize), position);
<span class="fc" id="L114">    decoder = DecoderFactory.get().directBinaryDecoder(bis, null);</span>
<span class="fc" id="L115">  }</span>

  /**
   * method useful when implementing tailing.
   *
   * @return true if size changed.
   * @throws IOException
   */
  public synchronized boolean reReadSize() throws IOException {
<span class="fc bfc" id="L124" title="All 2 branches covered.">    if (raf == null) {</span>
<span class="fc" id="L125">      raf = new RandomAccessFile(file, &quot;r&quot;);</span>
    }
<span class="fc" id="L127">    raf.seek(TSDBWriter.MAGIC.length);</span>
<span class="fc" id="L128">    long old = size;</span>
<span class="fc" id="L129">    size = raf.readLong();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (size != old) {</span>
<span class="fc" id="L131">      resetStream(bis.getCount());</span>
<span class="fc" id="L132">      return true;</span>
    } else {
<span class="fc" id="L134">      return false;</span>
    }
  }

  @Nullable
  public synchronized Either&lt;TableDef, DataBlock&gt; read() throws IOException {
<span class="fc" id="L140">    final long position = bis.getCount();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (position &gt;= size) {</span>
<span class="fc" id="L142">      return null;</span>
    }
    Object result;
    try {
<span class="fc" id="L146">      result = recordReader.read(null, decoder);</span>
<span class="nc" id="L147">    } catch (IOException | RuntimeException ex) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">      if (CORUPTION_LENIENT) {</span>
<span class="nc" id="L149">        return null;</span>
      } else {
<span class="nc" id="L151">        throw new IOException(&quot;Error reading tsdb file at &quot; + position + &quot;, this= &quot; + this, ex);</span>
      }
<span class="fc" id="L153">    }</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (result instanceof TableDef) {</span>
<span class="fc" id="L155">      final TableDef td = (TableDef) result;</span>
<span class="fc" id="L156">      long tdId = td.getId();</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">      if (position != tdId) {</span>
<span class="nc" id="L158">        throw new IOException(&quot;Table Id should be equal with file position &quot; + position + &quot;, &quot; + tdId);</span>
      }
<span class="fc" id="L160">      return Either.left(td);</span>
    } else {
<span class="fc" id="L162">      return Either.right((DataBlock) result);</span>
    }
  }

  @Override
  public synchronized void close() throws IOException {
<span class="fc" id="L168">    try (InputStream is = bis) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (raf != null) {</span>
<span class="fc" id="L170">        raf.close();</span>
      }
    }
<span class="fc" id="L173">  }</span>

  public synchronized long getSize() {
<span class="nc" id="L176">    return size;</span>
  }

  public Header getHeader() {
<span class="nc" id="L180">    return header;</span>
  }

  public void stopWatching() {
<span class="fc" id="L184">    watch = false;</span>
<span class="fc" id="L185">  }</span>

  public synchronized &lt;E extends Exception&gt; Future&lt;Void&gt; bgWatch(
          final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es) {
<span class="fc" id="L190">    return bgWatch(handler, es, ExecutionContexts.getContextDeadlineNanos());</span>
  }

  public synchronized &lt;E extends Exception&gt; Future&lt;Void&gt; bgWatch(
          final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es, final long timeout, final TimeUnit unit) {
<span class="nc" id="L196">    return bgWatch(handler, es, TimeSource.nanoTime() + unit.toNanos(timeout));</span>
  }

  //CHECKSTYLE:OFF
  public synchronized &lt;E extends Exception&gt; Future&lt;Void&gt; bgWatch(
          final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es, final long deadlineNanos) {
    //CHECKSTYLE:ON
<span class="fc" id="L204">    return DefaultExecutor.INSTANCE.submit(new Callable&lt;Void&gt;() {</span>

      @Override
      public Void call() throws Exception {
<span class="fc" id="L208">        watch(handler, es);</span>
<span class="fc" id="L209">        return null;</span>
      }
    });
  }

<span class="fc" id="L214">  public enum EventSensitivity {</span>
<span class="fc" id="L215">    HIGH, MEDIUM, LOW</span>
  }

  public &lt;E extends Exception&gt; void watch(final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es) throws IOException, InterruptedException, E {
<span class="fc" id="L220">    watch(handler, es, ExecutionContexts.getContextDeadlineNanos());</span>
<span class="fc" id="L221">  }</span>

  public &lt;E extends Exception&gt; void watch(final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es, final long timeout, final TimeUnit unit)
          throws IOException, InterruptedException, E {
<span class="nc" id="L226">    watch(handler, es, TimeSource.nanoTime() + unit.toNanos(timeout));</span>
<span class="nc" id="L227">  }</span>

  //CHECKSTYLE:OFF
  @SuppressFBWarnings(&quot;NOS_NON_OWNED_SYNCHRONIZATION&quot;)
  public &lt;E extends Exception&gt; void watch(final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final EventSensitivity es, final long deadlineNanos)
          throws IOException, InterruptedException, E {
    //CHECKSTYLE:ON
<span class="fc" id="L235">    synchronized (this) {</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">      if (watch) {</span>
<span class="nc" id="L237">        throw new IllegalStateException(&quot;File is already watched &quot; + file);</span>
      }
<span class="fc" id="L239">      watch = true;</span>
<span class="fc" id="L240">    }</span>
    SensitivityWatchEventModifier sensitivity;
<span class="pc bpc" id="L242" title="3 of 4 branches missed.">    switch (es) {</span>
      case LOW:
<span class="nc" id="L244">        sensitivity = SensitivityWatchEventModifier.LOW;</span>
<span class="nc" id="L245">        break;</span>
      case MEDIUM:
<span class="nc" id="L247">        sensitivity = SensitivityWatchEventModifier.MEDIUM;</span>
<span class="nc" id="L248">        break;</span>
      case HIGH:
<span class="fc" id="L250">        sensitivity = SensitivityWatchEventModifier.HIGH;</span>
<span class="fc" id="L251">        break;</span>
      default:
<span class="nc" id="L253">        throw new UnsupportedOperationException(&quot;Unsupported sensitivity &quot; + es);</span>
    }
<span class="fc" id="L255">    final Path path = file.getParentFile().toPath();</span>
<span class="fc" id="L256">    try (WatchService watchService = path.getFileSystem().newWatchService()) {</span>
<span class="fc" id="L257">      path.register(watchService, new WatchEvent.Kind[]{StandardWatchEventKinds.ENTRY_MODIFY,</span>
        StandardWatchEventKinds.OVERFLOW
      }, sensitivity);
<span class="fc" id="L260">      readAll(handler, deadlineNanos);</span>
      do {
<span class="fc" id="L262">        long tNanos = deadlineNanos - TimeSource.nanoTime();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (tNanos &lt;= 0) {</span>
<span class="nc" id="L264">          break;</span>
        }
<span class="fc" id="L266">        WatchKey key = watchService.poll(1, TimeUnit.SECONDS);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">          if (reReadSize()) {</span>
<span class="fc" id="L269">            readAll(handler, deadlineNanos);</span>
          }
          continue;
        }
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (!key.isValid()) {</span>
<span class="nc" id="L274">          key.cancel();</span>
<span class="nc" id="L275">          break;</span>
        }
<span class="pc bpc" id="L277" title="2 of 4 branches missed.">        if (!key.pollEvents().isEmpty() &amp;&amp; reReadSize()) {</span>
<span class="fc" id="L278">          readAll(handler, deadlineNanos);</span>
        }
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (!key.reset()) {</span>
<span class="nc" id="L281">          key.cancel();</span>
<span class="nc" id="L282">          break;</span>
        }
<span class="fc bfc" id="L284" title="All 2 branches covered.">      } while (watch);</span>
    } finally {
<span class="fc" id="L286">      watch = false;</span>
    }
<span class="fc" id="L288">  }</span>

  //CHECKSTYLE:OFF
  public synchronized &lt;E extends Exception&gt; void readAll(final Handler&lt;Either&lt;TableDef, DataBlock&gt;, E&gt; handler,
          final long deadlineNanos)
          throws IOException, E {
    //CHECKSTYLE:ON
    Either&lt;TableDef, DataBlock&gt; data;
<span class="fc bfc" id="L296" title="All 2 branches covered.">    while ((data = read()) != null) {</span>
<span class="fc" id="L297">      handler.handle(data, deadlineNanos);</span>
    }
<span class="fc" id="L299">  }</span>

  public synchronized void readAll(final Consumer&lt;Either&lt;TableDef, DataBlock&gt;&gt; consumer)
          throws IOException {
    Either&lt;TableDef, DataBlock&gt; data;
<span class="nc bnc" id="L304" title="All 2 branches missed.">    while ((data = read()) != null) {</span>
<span class="nc" id="L305">      consumer.accept(data);</span>
    }
<span class="nc" id="L307">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L311">    return &quot;TSDBReader{&quot; + &quot;size=&quot; + size + &quot;, raf=&quot; + raf + &quot;, file=&quot; + file + '}';</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>