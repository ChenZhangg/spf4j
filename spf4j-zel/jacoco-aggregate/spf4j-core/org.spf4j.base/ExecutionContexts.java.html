<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExecutionContexts.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-zel</a> &gt; <a href="../index.html" class="el_bundle">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.base</a> &gt; <span class="el_source">ExecutionContexts.java</span></div><h1>ExecutionContexts.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.base;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.Signed;
import javax.annotation.concurrent.ThreadSafe;
import org.spf4j.base.ExecutionContext.Relation;
import org.spf4j.concurrent.ScalableSequence;
import org.spf4j.concurrent.UIDGenerator;
import org.spf4j.ds.SimpleStack;

/**
 * @author Zoltan Farkas
 */
@ThreadSafe
@ParametersAreNonnullByDefault
public final class ExecutionContexts {

<span class="fc" id="L63">  private static final UIDGenerator ID_GEN = new UIDGenerator(new ScalableSequence(0, 10), &quot;X&quot;, 1544368928196L);</span>

<span class="fc" id="L65">  public static final long DEFAULT_TIMEOUT_NANOS</span>
<span class="fc" id="L66">          = Long.getLong(&quot;spf4j.execContext.defaultTimeoutNanos&quot;, TimeUnit.HOURS.toNanos(8));</span>

<span class="fc" id="L68">  private static final ThreadLocal&lt;SimpleStack&lt;ExecutionContext&gt;&gt; EXEC_CTX =</span>
<span class="fc" id="L69">          new ThreadLocal&lt;SimpleStack&lt;ExecutionContext&gt;&gt;() {</span>
    @Override
    protected SimpleStack&lt;ExecutionContext&gt; initialValue() {
<span class="fc" id="L72">      return new SimpleStack&lt;&gt;(4);</span>
    }

  };

<span class="fc" id="L77">  private static final ThreadLocalContextAttacher DEFAULT_TL_ATTACHER = new ThreadLocalContextAttacherImpl();</span>

<span class="fc" id="L79">  private static final ExecutionContextFactory&lt;ExecutionContext&gt; CTX_FACTORY = initFactory();</span>

<span class="fc" id="L81">  private static final ThreadLocalContextAttacher TL_ATTACHER =  initTLAttacher();</span>

  private ExecutionContexts() {
  }

  private static ThreadLocalContextAttacher initTLAttacher() {
<span class="fc" id="L87">    String factoryClass = System.getProperty(&quot;spf4j.execContext.tlAttacherClass&quot;);</span>
    ThreadLocalContextAttacher factory;
<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (factoryClass == null) {</span>
<span class="fc" id="L90">      factory = DEFAULT_TL_ATTACHER;</span>
    } else {
      try {
<span class="fc" id="L93">        factory = ((Class&lt;ThreadLocalContextAttacher&gt;) Class.forName(factoryClass)).newInstance();</span>
<span class="nc" id="L94">      } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {</span>
<span class="nc" id="L95">        throw new ExceptionInInitializerError(ex);</span>
<span class="fc" id="L96">      }</span>
    }
<span class="fc" id="L98">    return factory;</span>
  }

 private static ExecutionContextFactory&lt;ExecutionContext&gt; initFactory() {
<span class="fc" id="L102">    String factoryClass = System.getProperty(&quot;spf4j.execContext.factoryClass&quot;);</span>
    ExecutionContextFactory&lt;ExecutionContext&gt; factory;
<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (factoryClass == null) {</span>
<span class="fc" id="L105">      factory = new BasicExecutionContextFactory();</span>
    } else {
      try {
<span class="fc" id="L108">        factory = ((Class&lt;ExecutionContextFactory&lt;ExecutionContext&gt;&gt;) Class.forName(factoryClass)).newInstance();</span>
<span class="nc" id="L109">      } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {</span>
<span class="nc" id="L110">        throw new ExceptionInInitializerError(ex);</span>
<span class="fc" id="L111">      }</span>
    }
<span class="fc" id="L113">    String factoryWrapperClass = System.getProperty(&quot;spf4j.execContext.factoryWrapperClass&quot;);</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (factoryWrapperClass != null) {</span>
      try {
<span class="nc" id="L116">        factory = (ExecutionContextFactory&lt;ExecutionContext&gt;) Class.forName(factoryWrapperClass)</span>
<span class="nc" id="L117">                .getConstructor(ExecutionContextFactory.class).newInstance(factory);</span>
<span class="nc" id="L118">      } catch (ClassNotFoundException | InstantiationException | IllegalAccessException</span>
              | NoSuchMethodException | InvocationTargetException ex) {
<span class="nc" id="L120">        throw new ExceptionInInitializerError(ex);</span>
<span class="nc" id="L121">      }</span>
    }
<span class="fc" id="L123">    return factory;</span>
  }

  public static ThreadLocalContextAttacher defaultThreadLocalAttacher() {
<span class="fc" id="L127">    return DEFAULT_TL_ATTACHER;</span>
  }

  public static ThreadLocalContextAttacher threadLocalAttacher() {
<span class="fc" id="L131">    return TL_ATTACHER;</span>
  }

  public static CharSequence genId() {
<span class="fc" id="L135">    return ID_GEN.next();</span>
  }

  public static ExecutionContextFactory&lt;ExecutionContext&gt; getContextFactory() {
<span class="nc" id="L139">    return CTX_FACTORY;</span>
  }

  @Nullable
  public static ExecutionContext current() {
<span class="fc" id="L144">    return EXEC_CTX.get().peek();</span>
  }

  public static boolean inCurrentThread(final ExecutionContext ctx) {
<span class="nc" id="L148">    return EXEC_CTX.get().contains(ctx);</span>
  }

  public static void clearCurrentThread() {
<span class="nc" id="L152">     EXEC_CTX.get().clear();</span>
<span class="nc" id="L153">  }</span>

  /**
   * start a execution context.
   *
   * @param deadlineNanos the deadline for this context. (System.nanotime)
   * @return the execution context.
   */
  public static ExecutionContext start(final long startTimeNanos, final long deadlineNanos) {
<span class="nc" id="L162">    return start(&quot;anon&quot;, null, startTimeNanos, deadlineNanos);</span>
  }

  /**
   * start a execution context.
   *
   * @param timeout
   * @param tu
   * @return
   */
  public static ExecutionContext start(final long timeout, final TimeUnit tu) {
<span class="fc" id="L173">    return start(&quot;anon&quot;, current(), timeout, tu);</span>
  }

  public static ExecutionContext start(final String opname) {
<span class="nc" id="L177">    return start(opname, current(), DEFAULT_TIMEOUT_NANOS, TimeUnit.NANOSECONDS);</span>
  }

  public static ExecutionContext start(final String opname, final long timeout, final TimeUnit tu) {
<span class="fc" id="L181">    return start(opname, current(), timeout, tu);</span>
  }

  public static ExecutionContext start(@Nullable final ExecutionContext parent, final long timeout, final TimeUnit tu) {
<span class="nc" id="L185">    return start(&quot;anon&quot;, parent, timeout, tu);</span>
  }

  public static ExecutionContext start(@Nullable final ExecutionContext parent) {
<span class="fc" id="L189">    long nanoTime = TimeSource.nanoTime();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">    return start(parent, nanoTime, parent != null ? parent.getDeadlineNanos() : nanoTime + DEFAULT_TIMEOUT_NANOS);</span>
  }

  public static ExecutionContext start(@Nullable final ExecutionContext parent,
          final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L195">    return start(&quot;anon&quot;, parent, startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name, final long startTimeNanos, final long deadlineNanos) {
<span class="nc" id="L199">    return start(name, current(), startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name, final long deadlineNanos) {
<span class="fc" id="L203">    return start(name, current(), TimeSource.nanoTime(), deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name,
          @Nullable final ExecutionContext parent) {
<span class="fc" id="L208">    long nanoTime = TimeSource.nanoTime();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    return start(name, parent, nanoTime, parent != null ? parent.getDeadlineNanos()</span>
            : nanoTime + DEFAULT_TIMEOUT_NANOS);
  }

  public static ExecutionContext start(final String name,
          @Nullable final ExecutionContext parent, final long timeout, final TimeUnit tu) {
<span class="fc" id="L215">    return start(name, null, parent, timeout, tu);</span>
  }

  public static ExecutionContext start(final String name, @Nullable final CharSequence id,
          @Nullable final ExecutionContext parent, final long timeout, final TimeUnit tu) {
<span class="fc" id="L220">    long nanoTime = TimeSource.nanoTime();</span>
<span class="fc" id="L221">    return start(name, id, parent, nanoTime, computeDeadline(nanoTime, parent, tu, timeout));</span>
  }

  public static ExecutionContext createDetached(final String name,
          @Nullable final ExecutionContext parent, final long timeout, final TimeUnit tu) {
<span class="nc" id="L226">    long nanoTime = TimeSource.nanoTime();</span>
<span class="nc" id="L227">    return createDetached(name, parent, nanoTime, computeDeadline(nanoTime, parent, tu, timeout));</span>
  }

  public static ExecutionContext start(final String name,
          @Nullable final ExecutionContext parent, final long deadlineNanos) {
<span class="fc" id="L232">    return start(name, parent, TimeSource.nanoTime(), deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name,
          @Nullable final ExecutionContext parent, final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L237">    return start(name, null, parent, startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name, @Nullable final CharSequence id,
          @Nullable final ExecutionContext parent, final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L242">    return start(name, id, parent, Relation.CHILD_OF, startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext start(final String name, @Nullable final CharSequence id,
          @Nullable final ExecutionContext parent, final Relation relation,
          final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L248">    ExecutionContext nCtx = CTX_FACTORY.start(name, id, parent, relation,</span>
              startTimeNanos, deadlineNanos);
<span class="fc" id="L250">    nCtx.attach();</span>
<span class="fc" id="L251">    return nCtx;</span>
  }

  public static ExecutionContext createDetached(final String name,
          @Nullable final ExecutionContext parent, final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L256">    return createDetached(name, parent, Relation.CHILD_OF, startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext createDetached(final String name, @Nullable final ExecutionContext parent,
          final Relation relation, final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L261">    return createDetached(name, null, parent, relation, startTimeNanos, deadlineNanos);</span>
  }

  public static ExecutionContext createDetached(final String name,
          @Nullable final CharSequence id, @Nullable final ExecutionContext parent,
          final Relation relation, final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L267">    return CTX_FACTORY.start(name, id, parent, relation, startTimeNanos, deadlineNanos);</span>
  }

  public static long getContextDeadlineNanos() {
<span class="fc" id="L271">    ExecutionContext ec = ExecutionContexts.current();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (ec == null) {</span>
<span class="fc" id="L273">      return TimeSource.nanoTime() + DEFAULT_TIMEOUT_NANOS;</span>
    } else {
<span class="fc" id="L275">      return ec.getDeadlineNanos();</span>
    }
  }

  public static long getContextDeadlineNanos(final long currentTime) {
<span class="fc" id="L280">    ExecutionContext ec = ExecutionContexts.current();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">    if (ec == null) {</span>
<span class="nc" id="L282">      return currentTime + DEFAULT_TIMEOUT_NANOS;</span>
    } else {
<span class="fc" id="L284">      return ec.getDeadlineNanos();</span>
    }
  }

  @Signed
  public static long getTimeRelativeToDeadline(final TimeUnit unit) {
<span class="fc" id="L290">    return unit.convert(getContextDeadlineNanos() - TimeSource.nanoTime(), TimeUnit.NANOSECONDS);</span>
  }

  @Nonnegative
  public static long getTimeToDeadline(final TimeUnit unit) throws TimeoutException {
<span class="fc" id="L295">    long timeRelativeToDeadline = getTimeRelativeToDeadline(unit);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">    if (timeRelativeToDeadline &lt;= 0) {</span>
<span class="nc" id="L297">      throw new TimeoutException(&quot;Deadline exceeded by &quot; + (-timeRelativeToDeadline) + ' ' + unit);</span>
    }
<span class="fc" id="L299">    return timeRelativeToDeadline;</span>
  }

  @Nonnegative
  public static long getTimeToDeadlineUnchecked(final TimeUnit unit) {
<span class="nc" id="L304">    long timeRelativeToDeadline = getTimeRelativeToDeadline(unit);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (timeRelativeToDeadline &lt;= 0) {</span>
<span class="nc" id="L306">      throw new UncheckedTimeoutException(&quot;Deadline exceeded by &quot; + (-timeRelativeToDeadline) + ' ' + unit);</span>
    }
<span class="nc" id="L308">    return timeRelativeToDeadline;</span>
  }

  @Nonnegative
  public static int getTimeToDeadlineInt(final TimeUnit unit) throws TimeoutException {
<span class="nc" id="L313">    long timeRelativeToDeadline = getTimeToDeadline(unit);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (timeRelativeToDeadline &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L315">      return Integer.MAX_VALUE;</span>
    } else {
<span class="nc" id="L317">      return (int) timeRelativeToDeadline;</span>
    }
  }

  @Nonnegative
  public static long getMillisToDeadline() throws TimeoutException {
<span class="fc" id="L323">    return getTimeToDeadline(TimeUnit.MILLISECONDS);</span>
  }

  @Nonnegative
  public static int getSecondsToDeadline() throws TimeoutException {
<span class="nc" id="L328">    long secondsToDeadline = getTimeToDeadline(TimeUnit.SECONDS);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (secondsToDeadline &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L330">      return Integer.MAX_VALUE;</span>
    } else {
<span class="nc" id="L332">      return (int) secondsToDeadline;</span>
    }
  }

  public static long computeDeadline(final long timeout, final TimeUnit unit) {
<span class="fc" id="L337">    return computeDeadline(current(), timeout, unit);</span>
  }

  public static long computeTimeout(final long timeout, final TimeUnit unit) throws TimeoutException {
<span class="nc" id="L341">    return unit.convert(computeTimeoutDeadline(current(), unit, timeout).getTimeoutNanos(), TimeUnit.NANOSECONDS);</span>
  }

  /**
   * @deprecated use variant where the value and unit are it the natural order.
   */
  @Deprecated
  public static long computeDeadline(@Nullable final ExecutionContext current,
           final TimeUnit unit, final long timeout) {
<span class="nc" id="L350">    return computeDeadline(current, timeout, unit);</span>
  }

  public static long computeDeadline(@Nullable final ExecutionContext current,
          final long timeout, final TimeUnit unit) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (current == null) {</span>
<span class="fc" id="L356">      return TimeSource.getDeadlineNanos(timeout, unit);</span>
    }
<span class="fc" id="L358">    long nanoTime = TimeSource.nanoTime();</span>
<span class="fc" id="L359">    long ctxDeadlinenanos = current.getDeadlineNanos();</span>
<span class="fc" id="L360">    long timeoutNanos = unit.toNanos(timeout);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">    return (ctxDeadlinenanos - nanoTime &lt; timeoutNanos) ? ctxDeadlinenanos : nanoTime + timeoutNanos;</span>
  }

  public static long computeDeadline(final long startTimeNanos, @Nullable final ExecutionContext current,
          final TimeUnit unit, final long timeout) {
<span class="fc bfc" id="L366" title="All 2 branches covered.">    if (current == null) {</span>
<span class="fc" id="L367">      return TimeSource.getDeadlineNanos(startTimeNanos, timeout, unit);</span>
    }
<span class="fc" id="L369">    long ctxDeadlinenanos = current.getDeadlineNanos();</span>
<span class="fc" id="L370">    long timeoutNanos = unit.toNanos(timeout);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">    return (ctxDeadlinenanos - startTimeNanos &lt; timeoutNanos) ? ctxDeadlinenanos : startTimeNanos + timeoutNanos;</span>
  }

  /**
   * Compute the actual timeout taking in consideration the context deadline.
   * @param current the context
   * @param unit timeout unit
   * @param timeout timeout value
   * @return the earliest timeout (of the provided and context one)
   * @throws TimeoutException
   */
  public static TimeoutDeadline computeTimeoutDeadline(@Nullable final ExecutionContext current,
          final TimeUnit unit, final long timeout) throws TimeoutException {
<span class="nc bnc" id="L384" title="All 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L385">      return TimeoutDeadline.of(unit.toNanos(timeout), TimeSource.getDeadlineNanos(timeout, unit));</span>
    }
<span class="nc" id="L387">    long nanoTime = TimeSource.nanoTime();</span>
<span class="nc" id="L388">    long ctxDeadlinenanos = current.getDeadlineNanos();</span>
<span class="nc" id="L389">    long timeoutNanos = unit.toNanos(timeout);</span>
<span class="nc" id="L390">    long contextTimeoutNanos = ctxDeadlinenanos - nanoTime;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    return (contextTimeoutNanos &lt; timeoutNanos)</span>
<span class="nc" id="L392">            ? TimeoutDeadline.of(contextTimeoutNanos, ctxDeadlinenanos)</span>
<span class="nc" id="L393">            : TimeoutDeadline.of(timeoutNanos, nanoTime + timeoutNanos);</span>
  }

  private static class BasicExecutionContextFactory implements ExecutionContextFactory&lt;ExecutionContext&gt; {

    @Override
    public ExecutionContext start(final String name, @Nullable final CharSequence id,
            @Nullable final ExecutionContext parent, final Relation relation,
            final long startTimeNanos, final long deadlineNanos) {
<span class="fc" id="L402">      return new BasicExecutionContext(name, id, parent, relation, startTimeNanos, deadlineNanos);</span>
    }

  }

  public static &lt;T&gt; Callable&lt;T&gt; propagatingCallable(final Callable&lt;T&gt; callable) {
<span class="nc" id="L408">    ExecutionContext current = current();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">    return current == null ? callable : propagatingCallable(callable, current);</span>
  }

  public static &lt;T&gt; Callable&lt;T&gt; propagatingCallable(final Callable&lt;T&gt; callable, final ExecutionContext ctx) {
<span class="nc" id="L413">    return new PropagatingCallable&lt;T&gt;(callable, ctx);</span>
  }

  public static &lt;T&gt; Collection&lt;? extends Callable&lt;T&gt;&gt; propagatingCallables(
          final Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) {
<span class="nc" id="L418">    ExecutionContext current = current();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">    return current == null ? tasks : propagatingCallables(tasks, current);</span>
  }

  public static &lt;T&gt; Collection&lt;? extends Callable&lt;T&gt;&gt; propagatingCallables(
          final Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
          final ExecutionContext ctx) {
<span class="nc" id="L425">    return tasks.stream().map(</span>
<span class="nc" id="L426">            (c) -&gt; new PropagatingCallable&lt;&gt;(c, ctx))</span>
<span class="nc" id="L427">            .collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;(tasks.size())));</span>
  }

  public static &lt;T&gt; Collection&lt;? extends Callable&lt;T&gt;&gt; deadlinedPropagatingCallables(
          final Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
          final ExecutionContext ctx, final long deadlineNanos) {
<span class="nc" id="L433">    return tasks.stream().map(</span>
<span class="nc" id="L434">            (c) -&gt; new PropagatingNamedCallable&lt;&gt;(c, ctx, null, deadlineNanos))</span>
<span class="nc" id="L435">            .collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;(tasks.size())));</span>
  }

  public static &lt;T&gt; Callable&lt;T&gt; deadlinedPropagatingCallable(final Callable&lt;T&gt; callable,
          final ExecutionContext ctx, final long deadlineNanos) {
<span class="nc" id="L440">    return new PropagatingNamedCallable&lt;T&gt;(callable, ctx, null, deadlineNanos);</span>
  }

  public static Runnable propagatingRunnable(final Runnable runnable) {
<span class="fc" id="L444">    ExecutionContext current = current();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">    return current == null ? runnable : propagatingRunnable(runnable, current);</span>
  }

  public static Runnable propagatingRunnable(final Runnable runnable, final ExecutionContext ctx) {
<span class="fc" id="L449">    return new PropagatingRunnable(runnable, ctx, null, ctx.getDeadlineNanos());</span>
  }

  public static Runnable propagatingRunnable(final Runnable runnable, final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L454">    return new PropagatingRunnable(runnable, ctx, name, deadlineNanos);</span>
  }

  private static final class PropagatingCallable&lt;T&gt; implements Callable&lt;T&gt; {

    private final Callable&lt;T&gt; task;
    private final ExecutionContext current;

<span class="nc" id="L462">    PropagatingCallable(final Callable&lt;T&gt; task, final ExecutionContext current) {</span>
<span class="nc" id="L463">      this.task = task;</span>
<span class="nc" id="L464">      this.current = current;</span>
<span class="nc" id="L465">    }</span>

    @Override
    public T call() throws Exception {
<span class="nc" id="L469">      try (ExecutionContext ctx = current.startChild(task.toString())) {</span>
<span class="nc" id="L470">        return task.call();</span>
      }
    }
  }

  public static &lt;T&gt; Callable&lt;T&gt; propagatingCallable(final Callable&lt;T&gt; callable, final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L477">    return new PropagatingNamedCallable&lt;T&gt;(callable, ctx, name, deadlineNanos);</span>
  }


  private static final class PropagatingNamedCallable&lt;T&gt; implements Callable&lt;T&gt;, Wrapper&lt;Callable&lt;T&gt;&gt; {

    private final Callable&lt;T&gt; task;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingNamedCallable(final Callable&lt;T&gt; task, final ExecutionContext current,
<span class="nc" id="L491">            @Nullable final String name, final long deadlineNanos) {</span>
<span class="nc" id="L492">      this.task = task;</span>
<span class="nc" id="L493">      this.current = current;</span>
<span class="nc" id="L494">      this.name = name;</span>
<span class="nc" id="L495">      this.deadlineNanos = deadlineNanos;</span>
<span class="nc" id="L496">    }</span>

    @Override
    public T call() throws Exception {
<span class="nc" id="L500">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="nc" id="L501">        return task.call();</span>
      }
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L507" title="All 2 branches missed.">      return  name == null ? task.toString() : name;</span>
    }

    @Override
    public Callable&lt;T&gt; getWrapped() {
<span class="nc" id="L512">      return task;</span>
    }

  }

  public static &lt;X, Y&gt; Function&lt;X, Y&gt; propagatingFunction(final Function&lt;X, Y&gt; callable, final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L519">    return new PropagatingFunction&lt;X, Y&gt;(callable, ctx, name, deadlineNanos);</span>
  }

  private static final class PropagatingFunction&lt;X, Y&gt; implements Function&lt;X, Y&gt;, Wrapper&lt;Function&lt;X, Y&gt;&gt; {

    private final Function&lt;X, Y&gt; function;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingFunction(final Function&lt;X, Y&gt; task, final ExecutionContext current,
<span class="nc" id="L532">            final String name, final long deadlineNanos) {</span>
<span class="nc" id="L533">      this.function = task;</span>
<span class="nc" id="L534">      this.current = current;</span>
<span class="nc" id="L535">      this.name = name;</span>
<span class="nc" id="L536">      this.deadlineNanos = deadlineNanos;</span>
<span class="nc" id="L537">    }</span>

    @Override
    public Y apply(final X in) {
<span class="nc" id="L541">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="nc" id="L542">        return function.apply(in);</span>
      }
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L548" title="All 2 branches missed.">      return name == null ? function.toString() : name;</span>
    }

    @Override
    public Function&lt;X, Y&gt; getWrapped() {
<span class="nc" id="L553">      return function;</span>
    }

  }

  public static &lt;X, Y, Z&gt; BiFunction&lt;X, Y, Z&gt; propagatingBiFunction(final BiFunction&lt;X, Y, Z&gt; callable,
          final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L561">    return new PropagatingBiFunction&lt;X, Y, Z&gt;(callable, ctx, name, deadlineNanos);</span>
  }

 private static final class PropagatingBiFunction&lt;X, Y, Z&gt;
         implements BiFunction&lt;X, Y, Z&gt;, Wrapper&lt;BiFunction&lt;X, Y, Z&gt;&gt; {

    private final BiFunction&lt;X, Y, Z&gt; function;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingBiFunction(final BiFunction&lt;X, Y, Z&gt; task, final ExecutionContext current,
<span class="nc" id="L575">            final String name, final long deadlineNanos) {</span>
<span class="nc" id="L576">      this.function = task;</span>
<span class="nc" id="L577">      this.current = current;</span>
<span class="nc" id="L578">      this.name = name;</span>
<span class="nc" id="L579">      this.deadlineNanos = deadlineNanos;</span>
<span class="nc" id="L580">    }</span>

    @Override
    public Z apply(final X x, final Y y) {
<span class="nc" id="L584">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="nc" id="L585">        return function.apply(x, y);</span>
      }
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L591" title="All 2 branches missed.">      return name == null ? function.toString() : name;</span>
    }

    @Override
    public BiFunction&lt;X, Y, Z&gt; getWrapped() {
<span class="nc" id="L596">      return function;</span>
    }

  }


  public static &lt;X&gt; Consumer&lt;X&gt; propagatingConsumer(final Consumer&lt;X&gt; callable, final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L604">    return new PropagatingConsumer&lt;X&gt;(callable, ctx, name, deadlineNanos);</span>
  }

  private static final class PropagatingConsumer&lt;X&gt; implements Consumer&lt;X&gt;, Wrapper&lt;Consumer&lt;X&gt;&gt; {

    private final Consumer&lt;X&gt; function;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingConsumer(final Consumer&lt;X&gt; task, final ExecutionContext current,
<span class="nc" id="L617">            final String name, final long deadlineNanos) {</span>
<span class="nc" id="L618">      this.function = task;</span>
<span class="nc" id="L619">      this.current = current;</span>
<span class="nc" id="L620">      this.name = name;</span>
<span class="nc" id="L621">      this.deadlineNanos = deadlineNanos;</span>
<span class="nc" id="L622">    }</span>

    @Override
    public void accept(final X in) {
<span class="nc" id="L626">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="nc" id="L627">        function.accept(in);</span>
      }
<span class="nc" id="L629">    }</span>

    @Override
    public String toString() {
<span class="nc bnc" id="L633" title="All 2 branches missed.">      return name == null ? function.toString() : name;</span>
    }

    @Override
    public Consumer&lt;X&gt; getWrapped() {
<span class="nc" id="L638">      return function;</span>
    }

  }

  public static &lt;X&gt; Supplier&lt;X&gt; propagatingSupplier(final Supplier&lt;X&gt; callable, final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="nc" id="L645">    return new PropagatingSupplier&lt;X&gt;(callable, ctx, name, deadlineNanos);</span>
  }

private static final class PropagatingSupplier&lt;X&gt; implements Supplier&lt;X&gt;, Wrapper&lt;Supplier&lt;X&gt;&gt; {

    private final Supplier&lt;X&gt; function;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingSupplier(final Supplier&lt;X&gt; task, final ExecutionContext current,
<span class="nc" id="L658">            final String name, final long deadlineNanos) {</span>
<span class="nc" id="L659">      this.function = task;</span>
<span class="nc" id="L660">      this.current = current;</span>
<span class="nc" id="L661">      this.name = name;</span>
<span class="nc" id="L662">      this.deadlineNanos = deadlineNanos;</span>
<span class="nc" id="L663">    }</span>

    @Override
    public X get() {
<span class="nc" id="L667">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="nc" id="L668">        return function.get();</span>
      }
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L674" title="All 2 branches missed.">      return name == null ? function.toString() : name;</span>
    }

    @Override
    public Supplier&lt;X&gt; getWrapped() {
<span class="nc" id="L679">      return function;</span>
    }

  }


  public static &lt;X, Y&gt; BiConsumer&lt;X, Y&gt; propagatingBiConsumer(final BiConsumer&lt;X, Y&gt; callable,
          final ExecutionContext ctx,
          @Nullable final String name, final long deadlineNanos) {
<span class="fc" id="L688">    return new PropagatingBiConsumer&lt;&gt;(callable, ctx, name, deadlineNanos);</span>
  }

  private static final class PropagatingBiConsumer&lt;X, Y&gt; implements BiConsumer&lt;X, Y&gt;, Wrapper&lt;BiConsumer&lt;X, Y&gt;&gt; {

    private final BiConsumer&lt;X, Y&gt; function;
    private final ExecutionContext current;

    private final String name;

    private final long deadlineNanos;

    PropagatingBiConsumer(final BiConsumer&lt;X, Y&gt; task, final ExecutionContext current,
<span class="fc" id="L701">            final String name, final long deadlineNanos) {</span>
<span class="fc" id="L702">      this.function = task;</span>
<span class="fc" id="L703">      this.current = current;</span>
<span class="fc" id="L704">      this.name = name;</span>
<span class="fc" id="L705">      this.deadlineNanos = deadlineNanos;</span>
<span class="fc" id="L706">    }</span>

    @Override
    public void accept(final X x, final Y y) {
<span class="fc" id="L710">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="fc" id="L711">        function.accept(x, y);</span>
      }
<span class="fc" id="L713">    }</span>

    @Override
    public String toString() {
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">      return name == null ? function.toString() : name;</span>
    }

    @Override
    public BiConsumer&lt;X, Y&gt; getWrapped() {
<span class="nc" id="L722">      return function;</span>
    }

  }



  private static final class PropagatingRunnable implements Runnable, Wrapper&lt;Runnable&gt; {

    private final Runnable task;
    private final ExecutionContext current;
    private final String name;
    private final long deadlineNanos;

    PropagatingRunnable(final Runnable task, final ExecutionContext current, final String name,
<span class="fc" id="L737">            final long deadlineNanos) {</span>
<span class="fc" id="L738">      this.task = task;</span>
<span class="fc" id="L739">      this.current = current;</span>
<span class="fc" id="L740">      this.name = name;</span>
<span class="fc" id="L741">      this.deadlineNanos = deadlineNanos;</span>
<span class="fc" id="L742">    }</span>

    @Override
    public void run() {
<span class="fc" id="L746">      try (ExecutionContext ctx = start(toString(), current, deadlineNanos)) {</span>
<span class="fc" id="L747">        task.run();</span>
      }
<span class="fc" id="L749">    }</span>

    @Override
    public Runnable getWrapped() {
<span class="nc" id="L753">      return task;</span>
    }

    @Override
    public String toString() {
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">     return name == null ? task.toString() : name;</span>
    }
  }

  private static class ThreadLocalContextAttacherImpl implements ThreadLocalContextAttacher {

    @Override
    public Attached attach(final ExecutionContext ctx) {
<span class="fc" id="L766">      final Thread currentThread = Thread.currentThread();</span>
<span class="fc" id="L767">      SimpleStack&lt;ExecutionContext&gt; contextStack = ExecutionContexts.EXEC_CTX.get();</span>
<span class="fc" id="L768">      int stackPtr = contextStack.pushAndGetIdx(ctx);</span>
<span class="fc" id="L769">      return new AttachedImpl(currentThread, contextStack, ctx, stackPtr);</span>
    }

    private static class AttachedImpl implements Attached {

      private final Thread thread;
      private final SimpleStack&lt;ExecutionContext&gt; contextStack;
      private final ExecutionContext ctx;
      private final int stackPtr;

      AttachedImpl(final Thread currentThread,
              final SimpleStack&lt;ExecutionContext&gt; contextStack,
<span class="fc" id="L781">              final ExecutionContext ctx, final int stackPtr) {</span>
<span class="fc" id="L782">        this.thread = currentThread;</span>
<span class="fc" id="L783">        this.contextStack = contextStack;</span>
<span class="fc" id="L784">        this.ctx = ctx;</span>
<span class="fc" id="L785">        this.stackPtr = stackPtr;</span>
<span class="fc" id="L786">      }</span>

      @Override
      public void detach() {
<span class="fc" id="L790">        Thread now = Thread.currentThread();</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        if (now != thread) {</span>
<span class="nc" id="L792">          throw  new IllegalStateException(&quot;Detaching in different thread &quot; + thread + &quot; != &quot; + now);</span>
        }
<span class="fc" id="L794">        ExecutionContext pop = contextStack.pop();</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        if (pop != ctx) {</span>
<span class="nc" id="L796">          contextStack.push(pop);</span>
<span class="nc" id="L797">          throw new IllegalStateException(&quot;Detaching ctx that is not attached &quot; + ctx + &quot;, found: &quot; + pop);</span>
        }
<span class="fc" id="L799">      }</span>

      public boolean isTopOfStack() {
<span class="fc bfc" id="L802" title="All 2 branches covered.">        return stackPtr == 0;</span>
      }

      public Thread attachedThread() {
<span class="fc" id="L806">        return thread;</span>
      }

    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>