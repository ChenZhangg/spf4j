<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchemaCompileMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-maven-avro-schema-plugin - 8.6.28-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.maven.plugin.avro.avscp</a> &gt; <span class="el_source">SchemaCompileMojo.java</span></div><h1>SchemaCompileMojo.java</h1><pre class="source lang-java linenums">package org.spf4j.maven.plugin.avro.avscp;

import com.google.common.collect.Sets;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.avro.Protocol;
import org.apache.avro.Schema;
import org.apache.avro.SchemaRefWriter;
import org.apache.avro.compiler.idl.Idl;
import org.apache.avro.compiler.idl.ParseException;
import org.apache.avro.compiler.specific.SpecificCompiler;
import org.apache.avro.generic.GenericData;
import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.model.fileset.FileSet;
import org.apache.maven.shared.model.fileset.util.FileSetManager;
import org.spf4j.base.AppendableUtils;
import org.spf4j.base.PackageInfo;

/**
 * Mojo that will compile the avro sources: *.avsc, *.avpr, *.avdl in: 1) java files. 2) avsc files.
 *
 * @author Zoltan Farkas
 */
@Mojo(name = &quot;avro-compile&quot;,
        defaultPhase = LifecyclePhase.GENERATE_SOURCES,
        requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)
@SuppressFBWarnings(&quot;PATH_TRAVERSAL_IN&quot;)
<span class="nc" id="L66">public final class SchemaCompileMojo</span>
        extends SchemaMojoBase {

  public static final String SCHEMA_MANIFEST = &quot;codegen.properties&quot;;

  /**
   * The field visibility indicator for the fields of the generated class, as string values of
   * SpecificCompiler.FieldVisibility. The text is case insensitive.
   */
  @Parameter(name = &quot;fieldVisibility&quot;, defaultValue = &quot;PRIVATE&quot;)
  private String fieldVisibility;

  /**
   * The directory (within the java classpath) that contains the velocity templates to use for code generation. The
   * default value points to the templates included with the avro-maven-plugin.
   */
  @Parameter(name = &quot;templateDirectory&quot;,
          defaultValue = &quot;/org/apache/avro/compiler/specific/templates/java/classic/&quot;)
  private String templateDirectory;

  /**
   * Determines whether or not to create setters for the fields of the record. The default is to create setters.
   */
  @Parameter(name = &quot;createSetters&quot;,
          defaultValue = &quot;false&quot;)
  private boolean createSetters;

  /**
   * add maven coordinates to the schema. (group:artifact:version:ID) ID-&gt;Schema full name mapping file
   * schema_index.properties is packaged in the jar artifacts.
   */
<span class="nc" id="L97">  @Parameter(name = &quot;addMavenId&quot;,</span>
          defaultValue = &quot;true&quot;)
  private boolean addMavenId = true;

  /**
   * delete Protocol java files, this is when only the schema definitions are relevant.
   */
<span class="nc" id="L104">  @Parameter(name = &quot;deleteProtocolInterface&quot;,</span>
          defaultValue = &quot;true&quot;)
  private boolean deleteProtocolInterface = true;

  /**
   * set Java system properties that might control avro behavior.
   */
<span class="nc" id="L111">  @Parameter(name = &quot;systemProperties&quot;)</span>
  private Properties systemProperties = new Properties();


  /**
   * string type
   */
<span class="nc" id="L118">  @Parameter(name = &quot;stringType&quot;, defaultValue = &quot;String&quot;)</span>
  private String stringType = &quot;String&quot;;

<span class="nc" id="L121">  private int idSequence = 0;</span>

<span class="nc" id="L123">  private final Map&lt;String, Schema&gt; index = new HashMap&lt;&gt;();</span>

  private String attachMavenId(final Schema schema) {
<span class="nc" id="L126">    String exMvnId = schema.getProp(&quot;mvnId&quot;);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    if (exMvnId == null) {</span>
<span class="nc" id="L128">      String newId = genMnvId(schema);</span>
<span class="nc" id="L129">      schema.addProp(&quot;mvnId&quot;, newId);</span>
<span class="nc" id="L130">      return newId;</span>
    } else {
<span class="nc" id="L132">      return exMvnId;</span>
    }
  }

  public CharSequence getPackageMvnIdPrefix() {
<span class="nc" id="L137">    StringBuilder idBuilder = new StringBuilder(64);</span>
<span class="nc" id="L138">    idBuilder.append(mavenProject.getGroupId()).append(':').append(mavenProject.getArtifactId())</span>
<span class="nc" id="L139">            .append(':').append(mavenProject.getVersion());</span>
<span class="nc" id="L140">    return idBuilder;</span>
  }

  public String genMnvId(final Schema schema) {
<span class="nc" id="L144">    StringBuilder idBuilder = new StringBuilder(64);</span>
<span class="nc" id="L145">    idBuilder.append(mavenProject.getGroupId()).append(':').append(mavenProject.getArtifactId())</span>
<span class="nc" id="L146">            .append(':').append(mavenProject.getVersion());</span>
<span class="nc" id="L147">    StringBuilder idb = new StringBuilder(4);</span>
<span class="nc" id="L148">    AppendableUtils.appendUnsignedString(idb, idSequence, 5);</span>
<span class="nc" id="L149">    idBuilder.append(':').append(idb);</span>
<span class="nc" id="L150">    idSequence++;</span>
<span class="nc" id="L151">    index.put(idb.toString(), schema);</span>
<span class="nc" id="L152">    return idBuilder.toString();</span>
  }

  protected void doCompileIDL(final File sourceDir,  final String filename) throws IOException {
<span class="nc" id="L156">    Thread currentThread = Thread.currentThread();</span>
<span class="nc" id="L157">    ClassLoader contextClassLoader = currentThread.getContextClassLoader();</span>
    try {
<span class="nc" id="L159">      List&lt;URL&gt; runtimeUrls = createPathUrls(sourceDir);</span>
<span class="nc" id="L160">      URLClassLoader projPathLoader = AccessController.doPrivileged(</span>
              (PrivilegedAction&lt;URLClassLoader&gt;) ()
<span class="nc" id="L162">              -&gt; new URLClassLoader(runtimeUrls.toArray(new URL[runtimeUrls.size()]), contextClassLoader));</span>
<span class="nc" id="L163">      currentThread.setContextClassLoader(projPathLoader);</span>
<span class="nc" id="L164">      File file = new File(sourceDir, filename);</span>
<span class="nc" id="L165">      String sourceAbsolutePath = sourceDir.getAbsolutePath();</span>
      // set the current dir do that sourceIdl will be computed relative to it.
      // This makes this plugin not thread safe.
      Idl parser;
<span class="nc" id="L169">      String origCurrentDir = org.spf4j.base.Runtime.getCurrentDir();</span>
<span class="nc" id="L170">      org.spf4j.base.Runtime.setCurrentDir(sourceAbsolutePath);</span>
      try {
<span class="nc" id="L172">        parser = new Idl(file, projPathLoader);</span>
      } finally {
<span class="nc" id="L174">        org.spf4j.base.Runtime.setCurrentDir(origCurrentDir);</span>
      }
<span class="nc" id="L176">      Protocol protocol = parser.CompilationUnit();</span>
<span class="nc" id="L177">      publishSchemasAndAttachMvnIdToProtocol(protocol, false, useSchemaReferencesForAvsc);</span>
<span class="nc" id="L178">      SpecificCompiler compiler = new SpecificCompiler(protocol);</span>
<span class="nc" id="L179">      compiler.setOutputCharacterEncoding(mavenProject.getProperties().getProperty(&quot;project.build.sourceEncoding&quot;));</span>
<span class="nc" id="L180">      compiler.setStringType(GenericData.StringType.valueOf(stringType));</span>
<span class="nc" id="L181">      compiler.setTemplateDir(templateDirectory);</span>
<span class="nc" id="L182">      compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.valueOf(fieldVisibility));</span>
<span class="nc" id="L183">      compiler.setCreateSetters(createSetters);</span>
<span class="nc" id="L184">      compiler.compileToDestination(null, generatedJavaTarget);</span>
<span class="nc" id="L185">    } catch (ParseException e) {</span>
<span class="nc" id="L186">      throw new IOException(e);</span>
<span class="nc" id="L187">    } catch (DependencyResolutionRequiredException drre) {</span>
<span class="nc" id="L188">      throw new IOException(drre);</span>
    } finally {
<span class="nc" id="L190">      currentThread.setContextClassLoader(contextClassLoader);</span>
    }
<span class="nc" id="L192">  }</span>

  public List&lt;URL&gt; createPathUrls(final File sourceFolder)
          throws MalformedURLException, DependencyResolutionRequiredException {
<span class="nc" id="L196">    List&lt;String&gt; cpElements = mavenProject.getRuntimeClasspathElements();</span>
<span class="nc" id="L197">    List&lt;URL&gt; runtimeUrls = new ArrayList&lt;URL&gt;();</span>
<span class="nc" id="L198">    runtimeUrls.add(sourceFolder.toURI().toURL());</span>
    // If runtimeClasspathElements is not empty values add its values to Idl path.
<span class="nc bnc" id="L200" title="All 4 branches missed.">    if (cpElements != null &amp;&amp; !cpElements.isEmpty()) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">      for (Object runtimeClasspathElement : cpElements) {</span>
<span class="nc" id="L202">        String element = (String) runtimeClasspathElement;</span>
<span class="nc" id="L203">        runtimeUrls.add(new File(element).toURI().toURL());</span>
<span class="nc" id="L204">      }</span>
    }
<span class="nc" id="L206">    return runtimeUrls;</span>
  }

  private File addMvnIdsToIdl(final File idl, final URLClassLoader cl)
          throws IOException, ParseException {
<span class="nc bnc" id="L211" title="All 2 branches missed.">    if (!addMavenId) {</span>
<span class="nc" id="L212">      return idl;</span>
    }
<span class="nc" id="L214">    String charsetStr = mavenProject.getProperties().getProperty(&quot;project.build.sourceEncoding&quot;);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    Charset charset = charsetStr == null ? Charset.defaultCharset() : Charset.forName(charsetStr);</span>
<span class="nc" id="L216">    List&lt;String&gt; readAllLines = Files.readAllLines(idl.toPath(), charset);</span>
<span class="nc" id="L217">    Idl parser = new Idl(idl, cl);</span>
<span class="nc" id="L218">    Protocol protocol = parser.CompilationUnit();</span>
    // hack uses the same logic and Idl...
<span class="nc" id="L220">    String idlSource = new File(&quot;.&quot;).toURI().relativize(idl.toURI()).toString();</span>
<span class="nc" id="L221">    getLog().debug(&quot;Injecting mvnIds to &quot; + idlSource);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">    for (Schema s : protocol.getTypes()) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">      if (s.getProp(&quot;mvnId&quot;) != null) {</span>
<span class="nc" id="L224">        continue;</span>
      }
<span class="nc" id="L226">      String sourceIdl = s.getProp(&quot;sourceIdl&quot;);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (sourceIdl == null) {</span>
<span class="nc" id="L228">        getLog().warn(&quot;sourceIdl not available, will not attach mvnId for IDLs&quot;);</span>
<span class="nc" id="L229">        continue;</span>
      }
<span class="nc" id="L231">      SourceLocation sl = new SourceLocation(sourceIdl);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (!idlSource.equals(sl.getFilePath())) {</span>
<span class="nc" id="L233">        continue;</span>
      }
<span class="nc" id="L235">      int zbLineNr = sl.getLineNr() - 1;</span>
<span class="nc" id="L236">      String line = readAllLines.get(zbLineNr);</span>
<span class="nc" id="L237">      getLog().debug(&quot;inserting mvnId at &quot;</span>
              + sl + &quot; for line \&quot;&quot; + line + &quot;\&quot; schema: &quot; + s);
<span class="nc" id="L239">      int zbColNr = sl.getColNr() - 1;</span>
<span class="nc" id="L240">      readAllLines.set(zbLineNr, line.substring(0, zbColNr)</span>
<span class="nc" id="L241">              + &quot; @mvnId(\&quot;&quot; + genMnvId(s) + &quot;\&quot;) &quot;</span>
<span class="nc" id="L242">              + line.substring(zbColNr, line.length()));</span>
<span class="nc" id="L243">    }</span>
<span class="nc" id="L244">    Path tempIdl = Files.createTempFile(this.target.toPath(), idl.getName(), &quot;.tmp&quot;);</span>
<span class="nc" id="L245">    Files.write(tempIdl, readAllLines, charset);</span>
<span class="nc" id="L246">    return tempIdl.toFile();</span>
  }


  protected void doCompileSchemas(final String[] filenames)
          throws IOException {
<span class="nc" id="L252">    Schema.Parser parser = new Schema.Parser();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    for (String fileName : filenames) {</span>
<span class="nc" id="L254">      File src = new File(sourceDirectory, fileName);</span>
<span class="nc" id="L255">      Schema schema = parser.parse(src);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (addMavenId) {</span>
<span class="nc" id="L257">        attachMavenId(schema);</span>
      }
<span class="nc" id="L259">      String targetName = schema.getFullName().replace('.', File.separatorChar) + &quot;.avsc&quot;;</span>
<span class="nc" id="L260">      Path destination = generatedAvscTarget.toPath().resolve(targetName);</span>
<span class="nc" id="L261">      Path parent = destination.getParent();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">      if (parent != null) {</span>
<span class="nc" id="L263">        Files.createDirectories(parent);</span>
      }
<span class="nc" id="L265">      Files.write(destination,</span>
<span class="nc" id="L266">              schema.toString().getBytes(StandardCharsets.UTF_8),</span>
              StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
<span class="nc" id="L268">      SpecificCompiler compiler = new SpecificCompiler(schema);</span>
<span class="nc" id="L269">      compiler.setOutputCharacterEncoding(mavenProject.getProperties().getProperty(&quot;project.build.sourceEncoding&quot;));</span>
<span class="nc" id="L270">      compiler.setTemplateDir(templateDirectory);</span>
<span class="nc" id="L271">      compiler.setStringType(GenericData.StringType.valueOf(stringType));</span>
<span class="nc" id="L272">      compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.valueOf(fieldVisibility));</span>
<span class="nc" id="L273">      compiler.setCreateSetters(createSetters);</span>
<span class="nc" id="L274">      compiler.compileToDestination(src, generatedJavaTarget);</span>
    }
<span class="nc" id="L276">  }</span>

  protected void doCompileProtocol(final String filename, final Path destination) throws IOException {
<span class="nc" id="L279">    File src = new File(sourceDirectory, filename);</span>
<span class="nc" id="L280">    Protocol protocol = Protocol.parse(src);</span>
<span class="nc" id="L281">    publishSchemasAndAttachMvnIdToProtocol(protocol, addMavenId, useSchemaReferencesForAvsc);</span>
<span class="nc" id="L282">    SpecificCompiler compiler = new SpecificCompiler(protocol);</span>
<span class="nc" id="L283">    compiler.setOutputCharacterEncoding(mavenProject.getProperties().getProperty(&quot;project.build.sourceEncoding&quot;));</span>
<span class="nc" id="L284">    compiler.setTemplateDir(templateDirectory);</span>
<span class="nc" id="L285">    compiler.setStringType(GenericData.StringType.valueOf(stringType));</span>
<span class="nc" id="L286">    compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.valueOf(fieldVisibility));</span>
<span class="nc" id="L287">    compiler.setCreateSetters(createSetters);</span>
<span class="nc" id="L288">    compiler.compileToDestination(src, generatedJavaTarget);</span>
<span class="nc" id="L289">    Files.write(destination,</span>
<span class="nc" id="L290">            protocol.toString(true).getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L291">  }</span>



  private void publishSchemasAndAttachMvnIdToProtocol(final Protocol protocol,
          final boolean addMvnId, final boolean useSchemaReferences) throws IOException {
<span class="nc" id="L297">    Collection&lt;Schema&gt; types = protocol.getTypes();</span>
<span class="nc" id="L298">    Set&lt;String&gt; typeNames = Sets.newHashSetWithExpectedSize(types.size());</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    for (Schema schema : types) {</span>
<span class="nc" id="L300">      String fullName = schema.getFullName();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">      if (!typeNames.add(fullName)) {</span>
<span class="nc" id="L302">        continue;</span>
      }
<span class="nc" id="L304">      String targetName = fullName.replace('.', File.separatorChar) + &quot;.avsc&quot;;</span>
<span class="nc" id="L305">      Path destinationFile = generatedAvscTarget.toPath().resolve(targetName);</span>
<span class="nc" id="L306">      Path parent = destinationFile.getParent();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (parent != null) {</span>
<span class="nc" id="L308">        Files.createDirectories(parent);</span>
      }
<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (addMvnId) {</span>
<span class="nc" id="L311">        attachMavenId(schema);</span>
      }
<span class="nc bnc" id="L313" title="All 2 branches missed.">      if (useSchemaReferences) {</span>
<span class="nc" id="L314">        try (OutputStream fos =</span>
<span class="nc" id="L315">                new BufferedOutputStream(Files.newOutputStream(destinationFile,</span>
                        StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING))) {
<span class="nc" id="L317">          SchemaRefWriter.write(schema, fos);</span>
<span class="nc" id="L318">        }</span>
      } else {
<span class="nc" id="L320">        Files.write(destinationFile, schema.toString().getBytes(StandardCharsets.UTF_8),</span>
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
      }
<span class="nc" id="L323">    }</span>
<span class="nc" id="L324">  }</span>

  public void deleteGeneratedAvailableInDependencies() throws IOException {
<span class="nc" id="L327">    Path classesInfo = dependenciesDirectory.toPath().resolve(&quot;classes.txt&quot;);</span>
<span class="nc" id="L328">    Set&lt;String&gt; classes = new HashSet(Files.readAllLines(classesInfo, StandardCharsets.UTF_8));</span>
<span class="nc" id="L329">    Path javaPath = generatedJavaTarget.toPath();</span>
<span class="nc" id="L330">    try (Stream&lt;Path&gt; fsStream = Files.walk(javaPath)) {</span>
<span class="nc" id="L331">      List&lt;Path&gt; dupes = fsStream</span>
<span class="nc" id="L332">              .filter((p) -&gt; {</span>
<span class="nc" id="L333">                Path relativize = javaPath.relativize(p);</span>
<span class="nc" id="L334">                return classes.contains(relativize.toString().replace(&quot;.java&quot;, &quot;.class&quot;));</span>
<span class="nc" id="L335">              }).collect(Collectors.toList());</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">      for (Path p : dupes) {</span>
<span class="nc" id="L337">        Files.delete(p);</span>
<span class="nc" id="L338">        getLog().info(&quot;Deleted dupes: &quot; + dupes);</span>
<span class="nc" id="L339">      }</span>
    }
<span class="nc" id="L341">  }</span>

  public void deleteProtocolClasses() throws IOException {
<span class="nc" id="L344">    String detectionString = &quot;org.apache.avro.Protocol PROTOCOL&quot;;</span>
<span class="nc" id="L345">    Path javaPath = generatedJavaTarget.toPath();</span>
<span class="nc" id="L346">    String mSourceEncoding = mavenProject.getProperties().getProperty(&quot;project.build.sourceEncoding&quot;);</span>
    String sourceEncoding;
<span class="nc bnc" id="L348" title="All 2 branches missed.">    if (mSourceEncoding == null) {</span>
<span class="nc" id="L349">      sourceEncoding = Charset.defaultCharset().name();</span>
    } else {
<span class="nc" id="L351">      sourceEncoding = mSourceEncoding;</span>
    }
<span class="nc" id="L353">    try (Stream&lt;Path&gt; fsStream = Files.walk(javaPath)) {</span>
<span class="nc" id="L354">      List&lt;Path&gt; protocolFiles = fsStream</span>
<span class="nc" id="L355">              .filter((p) -&gt; {</span>
<span class="nc" id="L356">                Path fileName = p.getFileName();</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">                if (fileName == null || !fileName.toString().endsWith(&quot;.java&quot;)) {</span>
<span class="nc" id="L358">                  return false;</span>
                }
<span class="nc" id="L360">                try (BufferedReader br = Files.newBufferedReader(p, Charset.forName(sourceEncoding))) {</span>
                  String line;
<span class="nc bnc" id="L362" title="All 2 branches missed.">                  while ((line = br.readLine()) != null) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if (line.contains(detectionString)) {</span>
<span class="nc" id="L364">                      return true;</span>
                    }
                  }
<span class="nc" id="L367">                } catch (IOException ex) {</span>
<span class="nc" id="L368">                  getLog().info(&quot;cannot read file &quot; + p + &quot;, ignoring for cleanup&quot;, ex);</span>
<span class="nc" id="L369">                }</span>
<span class="nc" id="L370">                return false;</span>
<span class="nc" id="L371">              }).collect(Collectors.toList());</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">      for (Path p : protocolFiles) {</span>
<span class="nc" id="L373">        Files.delete(p);</span>
<span class="nc" id="L374">      }</span>
    }
<span class="nc" id="L376">  }</span>

  public void deleteSchemasAvailableInDependencies(final Path schTargetPath) throws IOException {
<span class="nc" id="L379">    Path classesInfo = dependenciesDirectory.toPath();</span>
<span class="nc" id="L380">    Set&lt;Path&gt; schemas = Files.walk(classesInfo).filter(</span>
            (p) -&gt; {
<span class="nc" id="L382">              Path fileName = p.getFileName();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">              return fileName == null ? false : fileName.toString().endsWith(&quot;avsc&quot;);</span>
            })
<span class="nc" id="L385">            .map((p) -&gt; classesInfo.relativize(p)).collect(Collectors.toSet());</span>
<span class="nc" id="L386">    List&lt;Path&gt; dupes = Files.walk(schTargetPath).filter((p) -&gt; schemas.contains(schTargetPath.relativize(p)))</span>
<span class="nc" id="L387">            .collect(Collectors.toList());</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    for (Path p : dupes) {</span>
<span class="nc" id="L389">      Files.delete(p);</span>
<span class="nc" id="L390">    }</span>
<span class="nc" id="L391">    getLog().info(&quot;Deleted dupes: &quot; + dupes);</span>
<span class="nc" id="L392">  }</span>

  @Override
  public void execute() throws MojoExecutionException, MojoFailureException {
<span class="nc" id="L396">    super.execute();</span>
<span class="nc" id="L397">    Log logger = this.getLog();</span>
<span class="nc" id="L398">    logger.info(&quot;Generationg java code + schemas, using avro &quot;</span>
<span class="nc" id="L399">            + PackageInfo.getPackageInfo(org.apache.avro.Schema.class.getName()));</span>
<span class="nc" id="L400">    synchronized (String.class) {</span>
<span class="nc" id="L401">      Properties properties = new Properties(System.getProperties());</span>
      try {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : ((Set&lt;Map.Entry&lt;String, String&gt;&gt;) ((Set) systemProperties.entrySet()))) {</span>
<span class="nc" id="L404">          System.setProperty(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L405">        }</span>
<span class="nc" id="L406">        Path generatedAvscTargetPath = generatedAvscTarget.toPath();</span>
<span class="nc" id="L407">        Files.createDirectories(generatedAvscTargetPath);</span>
<span class="nc" id="L408">        Files.createDirectories(generatedJavaTarget.toPath());</span>
<span class="nc" id="L409">        String[] sourceFiles = getSourceFiles(&quot;**/*.avsc&quot;);</span>
        try {
<span class="nc" id="L411">          doCompileSchemas(sourceFiles);</span>
<span class="nc" id="L412">        } catch (IOException ex) {</span>
<span class="nc" id="L413">          throw new MojoExecutionException(&quot;cannot compile schemas &quot; + Arrays.toString(sourceFiles), ex);</span>
<span class="nc" id="L414">        }</span>
<span class="nc" id="L415">        Path tmpSourceTarget = this.target.toPath().resolve(&quot;avro-sources&quot;);</span>
<span class="nc" id="L416">        compileAvpr(tmpSourceTarget);</span>
<span class="nc" id="L417">        addMvnIdToIdlsAndMoveToDestination(tmpSourceTarget);</span>
<span class="nc" id="L418">        compileIdl(tmpSourceTarget);</span>

<span class="nc" id="L420">        Path codegenManifest = generatedAvscTargetPath.resolve(SCHEMA_MANIFEST);</span>
        try {
<span class="nc" id="L422">          Files.write(codegenManifest,</span>
<span class="nc" id="L423">                  Collections.singletonList(&quot;Build-Time=&quot; + DateTimeFormatter.ISO_INSTANT.format(Instant.now()) + '\n'),</span>
                  StandardCharsets.UTF_8);
<span class="nc" id="L425">        } catch (IOException ex) {</span>
<span class="nc" id="L426">          throw new MojoExecutionException(&quot;Cannot create codegen manifest file &quot; + codegenManifest, ex);</span>
<span class="nc" id="L427">        }</span>
        try {
<span class="nc" id="L429">          deleteGeneratedAvailableInDependencies();</span>
<span class="nc" id="L430">          deleteSchemasAvailableInDependencies(getGeneratedAvscTarget().toPath());</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">          if (deleteProtocolInterface) {</span>
<span class="nc" id="L432">            deleteProtocolClasses();</span>
          }
<span class="nc" id="L434">        } catch (IOException ex) {</span>
<span class="nc" id="L435">          throw new MojoExecutionException(&quot;Cannot delete dependency dupes &quot; + this, ex);</span>
<span class="nc" id="L436">        }</span>
<span class="nc" id="L437">        Path indexFile = generatedAvscTargetPath.resolve(&quot;schema_index.properties&quot;);</span>
<span class="nc" id="L438">        try (BufferedWriter bw = Files.newBufferedWriter(indexFile,</span>
                StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
<span class="nc" id="L440">          bw.append(&quot;_pkg=&quot;);</span>
<span class="nc" id="L441">          bw.append(getPackageMvnIdPrefix());</span>
<span class="nc" id="L442">          bw.append('\n');</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">          for (Map.Entry&lt;String, Schema&gt; entry : index.entrySet()) {</span>
<span class="nc" id="L444">            bw.append(entry.getKey());</span>
<span class="nc" id="L445">            bw.append('=');</span>
<span class="nc" id="L446">            bw.append(entry.getValue().getFullName());</span>
<span class="nc" id="L447">            bw.append('\n');</span>
<span class="nc" id="L448">          }</span>
<span class="nc" id="L449">        } catch (IOException ex) {</span>
<span class="nc" id="L450">          throw new MojoExecutionException(&quot;Cannot generate schema index &quot; + this, ex);</span>
<span class="nc" id="L451">        }</span>
<span class="nc" id="L452">        mavenProject.addCompileSourceRoot(generatedJavaTarget.getAbsolutePath());</span>
<span class="nc" id="L453">        Resource resource = new Resource();</span>
<span class="nc" id="L454">        resource.setDirectory(this.generatedAvscTarget.getAbsolutePath());</span>
<span class="nc" id="L455">        resource.addInclude(&quot;**/*.avsc&quot;);</span>
<span class="nc" id="L456">        resource.addInclude(&quot;*.properties&quot;);</span>
<span class="nc" id="L457">        mavenProject.addResource(resource);</span>
<span class="nc" id="L458">        Resource resource2 = new Resource();</span>
<span class="nc" id="L459">        resource2.setDirectory(tmpSourceTarget.toString());</span>
<span class="nc" id="L460">        resource2.addInclude(&quot;**/*.avpr&quot;);</span>
<span class="nc" id="L461">        resource2.addInclude(&quot;**/*.avdl&quot;);</span>
<span class="nc" id="L462">        mavenProject.addResource(resource2);</span>
<span class="nc" id="L463">      } catch (IOException ex) {</span>
<span class="nc" id="L464">        throw new MojoExecutionException(&quot;cannot compile schemas, cfg = &quot; + this, ex);</span>
      } finally {
<span class="nc" id="L466">        System.setProperties(properties);</span>
      }
<span class="nc" id="L468">    }</span>
<span class="nc" id="L469">  }</span>

  public void compileIdl(final Path pSources) throws MojoExecutionException {
<span class="nc" id="L472">    File pSourcesFile = pSources.toFile();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    for (String file : getFiles(pSourcesFile, &quot;**/*.avdl&quot;)) {</span>
      try {
<span class="nc" id="L475">        doCompileIDL(pSourcesFile, file);</span>
<span class="nc" id="L476">      } catch (IOException ex) {</span>
<span class="nc" id="L477">        throw new MojoExecutionException(&quot;cannot compile &quot; + file, ex);</span>
<span class="nc" id="L478">      }</span>
    }
<span class="nc" id="L480">  }</span>

  public void addMvnIdToIdlsAndMoveToDestination(final Path destPath) throws MojoExecutionException {
<span class="nc" id="L483">    Thread currentThread = Thread.currentThread();</span>
<span class="nc" id="L484">    ClassLoader contextClassLoader = currentThread.getContextClassLoader();</span>
    try {
<span class="nc" id="L486">      List&lt;URL&gt; runtimeUrls = createPathUrls(this.sourceDirectory);</span>
<span class="nc" id="L487">      getLog().info(&quot;Compile classpath: &quot; + runtimeUrls);</span>
<span class="nc" id="L488">      URLClassLoader projPathLoader = AccessController.doPrivileged(</span>
              (PrivilegedAction&lt;URLClassLoader&gt;) ()
<span class="nc" id="L490">                      -&gt; new URLClassLoader(runtimeUrls.toArray(new URL[runtimeUrls.size()]), contextClassLoader));</span>
<span class="nc" id="L491">      currentThread.setContextClassLoader(projPathLoader);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">      for (String file : getSourceFiles(&quot;**/*.avdl&quot;)) {</span>
<span class="nc" id="L493">        Path destination = destPath.resolve(file);</span>
<span class="nc" id="L494">        Path parent = destination.getParent();</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L496">          Files.createDirectories(parent);</span>
        }
<span class="nc" id="L498">        File idlFile = new File(sourceDirectory, file);</span>
        try {
<span class="nc" id="L500">          idlFile = addMvnIdsToIdl(idlFile, projPathLoader);</span>
<span class="nc" id="L501">        } catch (ParseException | IOException | RuntimeException ex) {</span>
<span class="nc" id="L502">          throw new MojoExecutionException(&quot;cannot add mvnId to  IDL &quot; + idlFile + &quot;, &quot; + ex.getMessage(), ex);</span>
<span class="nc" id="L503">        }</span>
<span class="nc" id="L504">        Files.copy(idlFile.toPath(), destination, StandardCopyOption.REPLACE_EXISTING);</span>
      }
<span class="nc" id="L506">    } catch (IOException | DependencyResolutionRequiredException ex) {</span>
<span class="nc" id="L507">      throw new MojoExecutionException(&quot;cannot add mvnId to  IDL &quot; + this, ex);</span>
    } finally {
<span class="nc" id="L509">      currentThread.setContextClassLoader(contextClassLoader);</span>
    }
<span class="nc" id="L511">  }</span>

  public void compileAvpr(final Path pSources) throws MojoExecutionException {
<span class="nc bnc" id="L514" title="All 2 branches missed.">    for (String file : getSourceFiles(&quot;**/*.avpr&quot;)) {</span>
      try {
<span class="nc" id="L516">        Path destination = pSources.resolve(file);</span>
<span class="nc" id="L517">        Path folder = destination.getParent();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (folder != null) {</span>
<span class="nc" id="L519">          Files.createDirectories(folder);</span>
        }
<span class="nc" id="L521">        doCompileProtocol(file, destination);</span>
<span class="nc" id="L522">      } catch (IOException ex) {</span>
<span class="nc" id="L523">        throw new MojoExecutionException(&quot;cannot compile protocol &quot; + file, ex);</span>
<span class="nc" id="L524">      }</span>
    }
<span class="nc" id="L526">  }</span>

  public String[] getSourceFiles(final String pattern) {
<span class="nc" id="L529">    FileSetManager fsm = new FileSetManager();</span>
<span class="nc" id="L530">    FileSet fs = new FileSet();</span>
<span class="nc" id="L531">    fs.setDirectory(sourceDirectory.getAbsolutePath());</span>
<span class="nc" id="L532">    fs.addInclude(pattern);</span>
<span class="nc" id="L533">    fs.setFollowSymlinks(false);</span>
<span class="nc" id="L534">    return fsm.getIncludedFiles(fs);</span>
  }

  public static String[] getFiles(final File directory, final String pattern) {
<span class="nc" id="L538">    FileSetManager fsm = new FileSetManager();</span>
<span class="nc" id="L539">    FileSet fs = new FileSet();</span>
<span class="nc" id="L540">    fs.setDirectory(directory.getAbsolutePath());</span>
<span class="nc" id="L541">    fs.addInclude(pattern);</span>
<span class="nc" id="L542">    fs.setFollowSymlinks(false);</span>
<span class="nc" id="L543">    return fsm.getIncludedFiles(fs);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L548">    return &quot;SchemaCompileMojo{&quot; + &quot;fieldVisibility=&quot; + fieldVisibility</span>
            + &quot;, templateDirectory=&quot; + templateDirectory + &quot;, createSetters=&quot; + createSetters
<span class="nc" id="L550">            + &quot;, addMavenId=&quot; + addMavenId + &quot;, &quot; + super.toString() + '}';</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>